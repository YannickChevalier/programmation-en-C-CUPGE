\titre{\ttype}
\begin{comment}
  \section{Cours}

  \paragraph{Organisation de la mémoire.} On va créer des programmes
  qui traitent des données. Pour chaque programme:
  \begin{itemize}
  \item Les données sont conservées avec des \(0\) et des \(1\) dans
    la \emph{mémoire} (et ce sont des \emph{bits});
  \item La mémoire accessible est organisée en \emph{cases atomiques}
    qui ont chacune une adresse entre \(0\) et \(2^{31}-1\) ou
    \(2^{63}-1\);
  \item Les cases atomiques peuvent être regroupées en cases plus
    grandes, dont l'adresse est l'adresse de la première case
    atomique.
  \end{itemize}

  \paragraph{Types.} Un \emph{type} en C est défini par le nombre de
  cases atomiques qu'il faut pour stocker les valeurs de ce type et
  les opérations que le processeur peut faire sur les valeurs de ce
  type.

\begin{center}
  \fbox{~\parbox{0.9\textwidth}{
      \begin{trivlist}
      \item \textbf{Exemples:}
      \item ~
        \begin{itemize}
        \item Le type \texttt{char} est celui des entiers qui peuvent être stockés sur une seule case atomique (et chaque case atomique contient 8 bits);
        \item Sur les ordinateurs courants, le type \texttt{int} est celui des entiers qui peuvent être stockés sur 4 cases atomiques (32 bits);
        \item Sur tous les ordinateurs, le type \texttt{float} est celui des nombres à virgule qui peuvent être stockés sur 4 cases atomiques (32 bits);
        \item Attention, pour le processeur, la multiplication de 2 entiers n'a rien à voir avec la multiplication de 2 nombres à virgule (le nombre de cases ne suffit pas). 
        \end{itemize}
      \end{trivlist}
    }~}
\end{center}

\paragraph{Valeurs.} Une \emph{valeur} est une suite de bits qui a un
type. On peut changer le type d'une valeur en mettant le nouveau type
entre parenthèses devant.

\begin{center}
  \fbox{~\parbox{0.9\textwidth}{
      \begin{trivlist}
      \item \textbf{Exemples:}
      \item ~
        \begin{itemize}
        \item \texttt{'a'}, \texttt{'3'}, \(35\), \(-128\) sont des valeurs de type 
          \texttt{char}, qui sont des entiers entre \(-128\) et \(127\) (la valeur de
          \texttt{'a'} est \(97\) et celle de \texttt{'3'} est \(51\) dans le code ASCII)
        \item \(1.0 / 3.0 = 0.33\ldots\), mais \(1 / 3 = 0\) (la division sur des entiers
          est comme la division euclidienne)
        \item \texttt{( float ) 'a'} est le nombre à virgule 51.0;
        \item \texttt{( int ) 51.01} et \texttt{( int ) 51.99} sont tous les deux l'entier 
          \(51\) (arrondi à l'entier inférieur).
        \end{itemize}
      \end{trivlist}
    }~}
\end{center}

\paragraph{Variables.} Une \emph{variable} est une case d'un certain
type. La \emph{valeur} d'une variable est la suite de bits qu'elle
contient avec le même type que celui de la variable.
\begin{itemize}
\item Les programmes qu'on écrit en C sont \emph{compilés}: un
  programme traduit ce qu'on écrit en instructions pour le processeur;
\item C'est ce programme qui choisira l'adresse où les variables
  seront stockées;
\item Le programmeur doit juste donner un nom (avec un type) pour
  prévenir qu'il a besoin d'une variable.
\end{itemize}
\end{comment}

\exo{Déclarations de variables}
% 1
\prerequis\tio 1

\paragraph{Rappel:} Elle est déclarée par son type (qui est le type des
valeurs qu'elle peut contenir) et son adresse dans la mémoire. 
Quelques règles pour l'utilisation de variables:
\begin{enumerate}
\item toute variable doit être déclarée dans une fonction;
\item Le compilateur assure que toute variable déclarée est définie (a
  une case correspondante dans la mémoire) de manière unique pour
  chaque utilisation de la fonction;
  \begin{fminipage}{0.9\textwidth}
    En pratique, on ne fait pas de différence entre une variable et la
    case dans la mémoire qui lui est associée.
  \end{fminipage}
\item une variable est déclarée par un nom et un type:
  \begin{exemple}
    \begin{itemize}
    \item \texttt{int x} déclare une variable de nom \texttt{x} et de
      type \texttt{int}
    \item \texttt{char c} déclare une variable de nom \texttt{c} et de
      type \texttt{char}
    \end{itemize}
  \end{exemple}
\item Pour les déclarations complexes, on écrit les opérations qu'il
  faut faire sur la variable pour obtenir le type au début de la
  déclaration:
  \begin{exemple}
    \texttt{char * argv[]} signifie que \texttt{* argv[i]} (pour un
    entier \texttt{i}) est de type \texttt{char};
  \item Donc \texttt{argv[i]} est l'adresse d'une case qui contient un \texttt{char}
  \item Donc \texttt{argv} est un tableau dont les cases contiennent
    des adresses de cases de type \texttt{char}.
  \end{exemple}
\end{enumerate}

\question Dans le répertoire \url{~/workspace/src/Types}, ouvrir un
nouveau fichier \texttt{exercice\arabic{exercicenum}.c}, et écrire un
programme minimal.

\begin{solution}
  \begin{lstlisting}[language=C]
    #include <stdio.h>
    int
    main ( int argc , char * argv[ ] )
    {
      return 0 ;
    }
  \end{lstlisting}
\end{solution}

\question Modifiez le programme pour afficher la valeur de \texttt{argc}. 

\begin{solution}
  \begin{lstlisting}[language=C]
    #include <stdio.h>
    int
    main ( int argc , char * argv[ ] )
    {
      printf ( "argc vaut %d\n" , argc ) ;
      return 0 ;
    }
  \end{lstlisting}
\end{solution}

\question Compilez et exécutez le programme.

\question Exécutez le programme en mettant des mots et des nombres
après le nom du programme (sur la même ligne). Que vaut
\texttt{argc} ?

\begin{solution}
  \texttt{argc} vaut le nombre de mots (séparés par des espaces) qui
  sont après le nom du programme sur la même ligne.
\end{solution}

\exo{Adresses}
% 2

Les adresses ne sont pas des entiers, car les opérations possibles
sont différentes (on ne peut pas additionner, diviser ou multiplier
des adresses), mais elles sont stockées dans la mémoire dans le même
format que les entiers. L'adresse d'une variable \texttt{x} est
obtenue avec \texttt{\& x}. Une adresse peut être affichée avec la
directive \texttt{\%p}.

\question Créez un nouveau programme déclarant deux variables
\texttt{x0} et \texttt{x1} de type \texttt{int}, et affichez les
adresses de ces 2 variables.

\begin{solution}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x0 ;
  int x1 ;
  printf ( "l'adresse de x0 est %p.\n" , & x0 ) ;
  printf ( "l'adresse de x1 est %p.\n" , & x1 ) ;
  return 0 ;
}
  \end{lstlisting}
\end{solution}

\question On peut soustraire une adresse à une autre. Le résultat est
un entier long (de type \texttt{long int}, avec la directive
d'affichage \texttt{\%ld}). Modifiez le programme précédent pour
afficher la différence entre les adresses de \texttt{x0} et
\texttt{x1}.

\begin{solution}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x0 ;
  int x1 ;
  printf ( "l'adresse de x0 est %p.\n" , & x0 ) ;
  printf ( "l'adresse de x1 est %p.\n" , & x1 ) ;
  printf ( "& x1 - & x0 = %ld\n" , & x1 - & x0 ) ;
  return 0 ;
}
  \end{lstlisting}

  Suivant le choix, la différence n'est que \(1\) ou \(-1\), alors que si on
  regarde les adresses en hexadécimal, la différence est de 4.
\end{solution}

\question Ajoutez une variable \texttt{x2} et calculez les différences.


\begin{solution}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x0 ;
  int x1 ;
  int x2 ;
  printf ( "l'adresse de x0 est %p.\n" , & x0 ) ;
  printf ( "l'adresse de x1 est %p.\n" , & x1 ) ;
  printf ( "l'adresse de x2 est %p.\n" , & x2 ) ;
  printf ( "& x1 - & x0 = %ld\n" , & x1 - &x0 ) ;
  printf ( "& x2 - & x1 = %ld\n" , & x2 - & x1 ) ;
  printf ( "& x2 - & x0 = %ld\n" , & x2 - & x0 ) ;
  return 0 ;
}
  \end{lstlisting}
  Idem pour la différence des adresses !
\end{solution}

\question Pour la suite, on suppose que les variables sont déclarées
dans l'ordre \texttt{x0}, \texttt{x1}, \texttt{x2}. Suit on suit la
logique de la question précédente, l'adresse de \texttt{x2} est
l'adresse de \texttt{x0} plus 2, et celle de \texttt{x1} est celle de
\texttt{x0} plus 1. Donc en utilisant \texttt{*}, essayez de changer la
valeur des variables \texttt{x1} et \texttt{x2} juste en utilisant
l'adresse de \texttt{x0} (Il faut initialiser toutes les variables à
zéro pour que le compilateur soit satisfait).

\question Changez la valeur à l'adresse de \texttt{x0} moins 2 ou
\texttt{x0} moins 4, et affichez \texttt{argc}.

\begin{solution}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x0 = 0 ;
  int x1 = 0 ;
  int x2 = 0 ;
  printf ( "l'adresse de x0 est %p.\n" , & x0 ) ;
  printf ( "l'adresse de x1 est %p.\n" , & x1 ) ;
  printf ( "l'adresse de x2 est %p.\n" , & x2 ) ;
  printf ( "l'adresse de argc est %p.\n" , & argc ) ;
  printf ( "& x1 - & x0 = %ld\n" , &y - &x ) ;
  printf ( "& x2 - & x1 = %ld\n" , &z - &y ) ;
  printf ( "& x2 - & x0 = %ld\n" , &z - &x ) ;
  * ( & x0 - 2 ) = 0 ;
  * ( & x0 + 1 ) = 1 ;
  * ( & x0 + 2 ) = 2 ;
  * ( & x0 + 3 ) = 3 ;
  printf ( "x0 = %d, x1 = %d, x2 = %d\n" , x0 , x1 , x2 ) ;
  printf ( "argc = %d\n" , argc ) ;
  return 0 ;
}    
  \end{lstlisting}
  Morale: quand on fait des opérations sur les adresses, on ne sait
  pas forcément ce qu'on modifie. 
\end{solution}

\question Changez les types de \texttt{x0}, \texttt{x1}, et
\texttt{x2} en \texttt{char} au lieu d'\texttt{int}. Que remarque-t'on
?

\begin{solution}
  De prime abord, c'est n'importe quoi:
  \begin{itemize}
  \item Maintenant, la différence entre les adresses réelles est de 1 ( et plus 4);
  \item Mais la soustraction entre les adresses et l'addition d'un entier à une adresse
    continuent de fonctionner correctement.
  \end{itemize}
  L'explication est simple:
  \begin{itemize}
  \item Pour stocker un entier de type \texttt{int}, il faut 4 cases
    de type \texttt{char};
  \item L'adresse d'une case est l'adresse de la première case de type
    \texttt{char} qu'elle contient;
  \item Donc quand le compilateur met les variables de type
    \texttt{int} les unes après les autres, leur adresse réelle varie
    de 4 en 4. Et quand ce sont des adresses de type \texttt{char},
    leur adresse réelle varie de 1 en 1;
  \item Par contre, la soustraction entre adresses renvoie le nombre
    de cases du même type (de la même taille) entre les 2 adresses, et
    l'addition renvoie l'adresse de la \textit{i}ème case du type
    après la case courante.
  \end{itemize}
\end{solution}

\question Pour conclure, \texttt{sizeof} calcule le nombre de cases
qu'il faut pour stocker une variable. Affichez ce nombre pour les types suivants:
\begin{center}
  \texttt{char}, \texttt{short int} , \texttt{int}, \texttt{long int}, \texttt{float}, \texttt{double}, \texttt{int *}, \texttt{char *}
\end{center}


\exo{Tableaux}
% 3

Ce qu'on a vu lors de l'exercice précédent n'est pas ``normal'': on a
utilisé notre connaissance du fonctionnement de gcc pour savoir quelle
était l'adresse d'autres variables à partir d'une adresse connue. La
méthode \emph{standard} pour déclarer plusieurs variables du même type
en C est de déclarer un tableau.

\question Dans un nouveau fichier
\texttt{exercice\label{exercicenum}.c} et:
\begin{enumerate}
\item remplacer les 3 déclarations de variables par:
  \begin{lstlisting}[language=C]
    int x[3] ;
  \end{lstlisting}
\item remplacer partout \texttt{x0} par \texttt{x[0]}, \texttt{x1} par
  \texttt{x[1]}, et \texttt{x2} par \texttt{x[2]}.
\end{enumerate}
Compilez et exécuter le programme.

\begin{solutioncachee}
  On n'a pas initialisé les variables du tableau, donc x[0] a une
  valeur quelconque, mais pour le reste, on obtient exactement les
  mêmes résultats qu'avant.
\end{solutioncachee}

\begin{fminipage}{0.9\textwidth}
  La déclaration \texttt{int x[3]} déclare une suite (un tableau) de 3
  variables \texttt{x[0]}, \texttt{x[1]}, et \texttt{x[2]}.

  \large \texttt{x} n'est pas une variable !
\end{fminipage}

\question Affichez la valeur de \texttt{x} en utilisant la directive
des adresses. Que remarque-t'on ?

\begin{solutioncachee}
  La \emph{valeur} de \texttt{x} est l'\emph{adresse} de \texttt{x[0]}.
\end{solutioncachee}

\question Affichez l'adresse de \texttt{x}. Affichez les tailles de \texttt{x} et de \texttt{\& x}. Que remarque-t'on ?


\begin{solutioncachee}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x[3] ;
  printf ( "l'adresse de x[0] est %p.\n" , & x[0] ) ;
  printf ( "l'adresse de x[1] est %p.\n" , & x[1] ) ;
  printf ( "l'adresse de x[2] est %p.\n" , & x[2] ) ;
  printf ( "la valeur de x est %p.\n" , x ) ;
  printf ( "l'adresse de x est %p.\n" , & x ) ;
  printf ( "& x[1] - & x[0] = %ld\n" , & x[1] - & x[0] ) ;
  printf ( "& x[2] - & x[1] = %ld\n" , & x[2] - & x[1] ) ;
  printf ( "& x[2] - & x[0 = %ld\n" , & x[2] - & x[0] ) ;
  * ( & x[0] - 2 ) = 0 ;
  * ( & x[0] + 1 ) = 1 ;
  * ( & x[0] + 2 ) = 2 ;
  * ( & x[0] + 3 ) = 3 ;
  printf ( "x[0] = %d, x[1] = %d, x[2] = %d\n" , x[0] , x[1] , x[2] ) ;
  printf ( "sizeof ( x ) = %ld\n" , sizeof ( x ) ) ;
  printf ( "sizeof ( & x ) = %ld\n" , sizeof ( & x ) ) ;
  return 0 ;
}    
  \end{lstlisting}


  C'est la même adresse que celle de x[0]. Tout se passe comme si on
  avait déclaré une très grande case pouvant contenir 3 entier:
  \begin{itemize}
  \item La valeur de \texttt{x} est l'adresse de la première case
    \texttt{x[0]} du tableau;
  \item La taille de \texttt{x} est la somme des tailles des cases ;
  \item La valeur de \texttt{\& x} est l'adresse du début de cette grande case;
  \item La taille de \texttt{\& x} est la taille normale des adresses.
  \end{itemize}
\end{solutioncachee}

\begin{fminipage}{0.9\textwidth}
  Les tableaux ont les propriétés suivantes:
  \begin{itemize}
  \item \texttt{x[i] = * ( x + i )}
  \item \texttt{\& x[i] = \& * ( x + i ) = x + i}
  \end{itemize}
\end{fminipage}

\question Vérifiez ces égalités en simplifiant le programme, et en
vérifiant que les résultats sont les mêmes.


\begin{solutioncachee}
  \begin{lstlisting}[language=C]
#include <stdio.h>

int
main ( int argc , char * argv[] )
{
  int x[3] ;
  printf ( "l'adresse de x[0] est %p.\n" , x ) ;
  printf ( "l'adresse de x[1] est %p.\n" , x + 1 ) ;
  printf ( "l'adresse de x[2] est %p.\n" , x + 2 ) ;
  printf ( "la valeur de x est %p.\n" , x ) ;
  printf ( "l'adresse de x est %p.\n" , & x ) ;
  printf ( "& x[1] - & x[0] = %ld\n" , ( x + 1 ) - ( x + 0 ) ) ; // = 1
  printf ( "& x[2] - & x[1] = %ld\n" , ( x + 2 ) - ( x + 1 ) ) ; // =1
  printf ( "& x[2] - & x[0 = %ld\n" , ( x + 2 )  - ( x + 0 ) ) ; // = 2
  x[-2] = 0 ;
  x[0] = 1 ;
  x[1] = 2 ;
  x[2] = 3 ;
  printf ( "x[0] = %d, x[1] = %d, x[2] = %d\n" , x[0] , x[1] , x[2] ) ;
  printf ( "sizeof ( x ) = %ld\n" , sizeof ( x ) ) ;
  printf ( "sizeof ( & x ) = %ld\n" , sizeof ( & x ) ) ;
  return 0 ;
}    
  \end{lstlisting}
\end{solutioncachee}
