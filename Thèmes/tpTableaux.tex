\titre{\ttableaux}




\exo{Crible d'Érathostène Simple}
% 1
\prerequis \tio 6

L'algorithme du crible d'Érathostène est utilisé pour calculer en une
fois tous les nombres premiers jusqu'à une certaine limite. On veut
calculer un tableau \texttt{t} d'entiers tel que \texttt{t[i] = 1} si,
et seulement si, \texttt{i} est un nombre premier. Tout le travail se
fait dans le fichier \texttt{exercice\arabic{exercicenum}.c} à partir
du programme de base.

\question On commence par fixer la taille maximale qu'on accepte pour
tester des nombres premiers. Ajouter en haut du fichier, après
l'inclusion de \texttt{stdio.h}:
\begin{lstlisting}[language=C]
#define TAILLE 100000
\end{lstlisting}

\question On va écrire une fonction \texttt{crible} calculant le crible. Pour celà:
\begin{itemize}
\item il faut déclarer dans la fonction \texttt{main} un tableau
  d'entiers \emph{t} de \texttt{TAILLE} cases;
\item appeler la fonction \texttt{crible} avec l'adresse de ce tableau
  comme paramètre.
\end{itemize}
Commencez par écrire une fonction \texttt{crible} qui ne fait rien,
mais est appelée avec les bons arguments, et vérifiez que le programme
compile correctement.

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
 #include <stdio.h>

#define TAILLE 100000

void crible ( int * t )
{
}


int
main ( int argc , char * argv[] )
{
    int n ;
    int t[TAILLE] ;
    if ( crible ( t , TAILLE ) != 0 )
    {
        printf ( "Il y a eu une erreur lors du calcul.\n" ) ;
        return 1 ;
    }
    while ( 1 )
    {
        printf ( "Donnez un entier strictement inférieur à %d:\n" , TAILLE ) ;
        scanf ( "%d" , & n ) ;
        if ( n < 0 )
            break ;
        if ( n >= TAILLE )
            continue ;
        if ( t[n] == 1 )
            printf ( "%d est un nombre premier.\n" , n ) ;
        else
            printf ( "%d n'est pas un nombre premier.\n" , n ) ;
    }
    return 0 ;
} 
  \end{lstlisting}
\end{solutioncachee}

\question Lorsqu'on programme en C, il est recommandé de suivre la
recommandation suivante:
\begin{itemize}
\item si une fonction n'a pas eu d'erreur, elle renvoie l'entier 0;
\item sinon, elle renvoie un entier (le code d'erreur) qui indique
  quelle a été l'erreur.
\end{itemize}
Modifiez le programme pour qu'en cas d'erreur de la fonction
\texttt{crible}, la fonction \texttt{main} s'arrête immédiatement en
renvoyant un entier \(> 0\).
\begin{solutioncachee}
  \begin{lstlisting}[language=C]
    if ( crible ( t  ) != 0 )
    {
        printf ( "Il y a eu une erreur lors du calcul.\n" ) ;
        return 1 ;
    }
  \end{lstlisting}
\end{solutioncachee}

\question Dans la fonction \texttt{crible}, commencez par mettre les
deux premières cases à \(0\) (car \(0\) et \(1\) ne sont pas premiers)
et toutes les autres à \(1\). Compilez et vérifiez que le programme
s'exécute correctement, même s'il ne fait rien pour l'instant.

\question L'algorithme du crible d'Érathostène contient 2 boucles imbriquées:
\begin{itemize}
\item La première parcourt toutes les cases du tableau. Pour chaque case \(i\):
  \begin{itemize}
  \item Si \(t[i]=0\), passer à la case suivante;
  \item Si \(t[i]=1\), alors \(i\) est un nombre premier, et:
    \begin{itemize}
    \item Pour tous les \(j\ge 2\) tels que \(i*j\le \text{\tt TAILLE}\), mettre
      la case \(i*j\) à 0 (car \(i*j\) est un multiple de \(i\)).
    \end{itemize}
  \end{itemize}
\end{itemize}

\question Modifiez la boucle externe pour ne pas parcourir toutes les
cases jusqu'à \texttt{TAILLE} et vous arrêter avant. 

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int crible ( int * t )
{
    int i , j ;
    if ( TAILLE < 2 )
        return 1 ;
    t[0] = t[1] = 0 ;
    for ( i = 2 ; i < TAILLE ; i++ )
        t[i] = 1 ;
    for ( i = 2 ; i * i < TAILLE ; i++ )
        if ( t[i] == 1 )
            for ( j = 2 ; i * j < n ; j++ )
                t[i*j] = 0
    return  0 ;
}    
  \end{lstlisting}
\end{solutioncachee}

\question Dans la fonction \texttt{main}, faire une boucle infinie
(dont la condition est toujours vraie) demandant à l'utilisateur un entier
et faisant:
\begin{itemize}
\item Si l'entier est strictement négatif, on sort de la boucle avec
  \texttt{break} (c'est le seul moyen de sortir de cette boucle
  infinie);
\item Si l'entier est plus grand ou égal à la taille, on ne peut pas
  faire de calcul, donc on passe à l'itération suivante avec \texttt{continue};
\item Sinon, il faut afficher si l'entier \(i\) qui a été lu est
  premier en regardant la valeur de \(t[i]\).

\end{itemize}

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int
main ( int argc , char * argv[] )
{
    int n ;
    int t[TAILLE] ;
    if ( crible ( t , TAILLE ) != 0 )
    {
        printf ( "Il y a eu une erreur lors du calcul.\n" ) ;
        return 1 ;
    }
    while ( 1 )
    {
        printf ( "Donnez un entier strictement inférieur à %d:\n" , TAILLE ) ;
        scanf ( "%d" , & n ) ;
        if ( n < 0 )
            break ;
        if ( n >= TAILLE )
            continue ;
        if ( t[n] == 1 )
            printf ( "%d est un nombre premier.\n" , n ) ;
        else
            printf ( "%d n'est pas un nombre premier.\n" , n ) ;
    }
    return 0 ;
}    
  \end{lstlisting}
\end{solutioncachee}

\exo{Crible d'Érathostène utile}
% 2

Commencez par copier dans \texttt{exercice\arabic{exercicenum}.c} le
programme de l'exercice précédent.

\question Modifiez la fonction \texttt{crible} pour que la case \(t[i]\) contienne:
\begin{itemize}
\item \(i\) si \(i\) est un nombre premier;
\item \(j\) qui est le plus grand diviseur premier de \(i\) sinon.
\end{itemize}
Pour \(i=1\), on prend \(t[1]=1\).


\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int crible ( int * t )
{
    int i , j ;
    t[0] = 0 ;
    t[1] = 1 ;
    for ( i = 2 ; i < TAILLE ; i++ )
        t[i] = i ;
    for ( i = 2 ; i * i < TAILLE ; i++ )
        if ( t[i] == i )
            for ( j = 2 ; i * j < TAILLE ; j++ )
                t[i*j] = i ;
    return  0 ;
}
  \end{lstlisting}
\end{solutioncachee}

\question Écrivez une fonction qui prend en entrée le crible et un
entier, et affiche la décomposition en facteurs premiers de cet
entier.


\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int
decomposition ( int * t , int i )
{
    int j ;
    if ( ( i < 1 ) || ( i >= TAILLE ) )
    {
        printf ( "Pas de décomposition possible pour %d.\n" , i ) ;
        return 1 ;
    }
    for ( j = i ; t[j] != j ; j = j / t[j] )
        printf ( "%d " , t[j] ) ;
    printf ( "%d\n" , t[j] ) ;
    return 0 ;
}
  \end{lstlisting}
\end{solutioncachee}

\question Modifiez la fonction \texttt{main} pour qu'elle affiche la
décomposition en facteurs premiers des entiers que donne
l'utilisateur.

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int
main ( int argc , char * argv[] )
{
    int n ;
    int t[TAILLE] ;
    if ( crible ( t ) != 0 )
    {
        printf ( "Il y a eu une erreur lors du calcul.\n" ) ;
        return 1 ;
    }
    while ( 1 )
    {
        printf ( "Donnez un entier strictement inférieur à %d:\n" , TAILLE ) ;
        scanf ( "%d" , & n ) ;
        if ( n < 0 )
            break ;
        if ( n >= TAILLE )
            continue ;
        printf ( "La décomposition de %d en facteurs premiers est:\n\t" , n ) ;
        decomposition ( t , n ) ;
    }
    return 0 ;
}
  \end{lstlisting}
\end{solutioncachee}

\exo{Recherche de majorité}

Le but de cet exercice est de chercher dans un tableau d'entiers
aléatoires si une des valeurs apparaît dans plus de la moitié des
cases.

\begin{fminipage}{0.9\textwidth}
  \textbf{Obtenir un entier aléatoire.} Pour obtenir un entier
  suffisament aléatoire, on va utiliser un \emph{générateur de nombres
    pseudo-aléatoires}. Ce générateur doit être \emph{initialisé} par
  un entier différent à chaque lancement du programme, sinon ce seront
  toujours les mêmes nombres qui seront choisis. Pour celà, on
  initialise le GNPA avec l'heure actuelle:
  \begin{lstlisting}[language=C]
    srand ( time ( NULL ) ) ;
  \end{lstlisting}
  Il est nécessaire d'inclure les bibliothèques \texttt{time.h} et
  \texttt{stdlib.h}. Ensuite, chaque fois qu'on a besoin d'un entier
  aléatoire, on appelle la fonction \texttt{rand}.
\end{fminipage}

On fixe une taille de tableau à 10 éléments.


\question Écrire un programme qui demande à l'utilisateur un entier
positif \(n\), et initialise un tableau \texttt{t} avec des entiers
entre \(0\) et \(n-1\).

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAILLE 10

void initialise ( int * t , int modulo )
{
    int i ;
    for ( i = 0 ; i < TAILLE ; i++ )
        t[i] = rand ( ) % modulo ;
}
void lit_entier_positif ( int * n )
{
    int lu , c ;
    do
    {
        printf ( "Donnez un entier positif:\n" ) ;
        lu = scanf ( "%d" , n ) ;
        do
        {
            c = getchar ( ) ;
        } while ( c != '\n') ;
    } while ( ( lu != 1 ) || ( *n <= 0 ) ) ;
    
}
int 
main ( int argc , char * argv[] )
{
    int n ;
    int t[TAILLE] ;
    srand ( time ( NULL ) ) ;
    printf ( "Choisissez le nombre de valeurs différentes possibles:\n" ) ;
    lit_entier_positif ( & n ) ;
    initialise ( t , n ) ;
    return 0 ;
}

  \end{lstlisting}
\end{solutioncachee}

La recherche d'un candidat majoritaire se fait en 2 phases:
\begin{enumerate}
\item d'abord, on parcourt une fois toutes les cases du tableau pour trouver
  un candidat possible. Pour celà:
  \begin{itemize}
  \item si la majorité actuelle est de 0, l'élément courant devient candidat avec une majorité de 1;
  \item si la majorité actuelle est strictement plus grande que 0:
    \begin{itemize}
    \item si l'élément courant est égal au candidat courant, on augmente la majorité de 1 ;
    \item sinon, on diminue la majorité de 1
    \end{itemize}
  \end{itemize}
  Cet algorithme garantit que \textbf{s'il existe un élément majoritaire}, alors le candidat est cet élément;
\item Ensuite, on parcourt le tableau une deuxième fois, et on compte
  le nombre de fois où le candidat apparaît.
  \begin{itemize}
  \item Si ce nombre est strictement supérieur à \texttt{TAILLE / 2}
    alors on a trouvé l'élément majoritaire;
  \item Sinon, aucune valeur n'est majoritaire.
  \end{itemize}
\end{enumerate}

\question Écrire la fonction \texttt{trouve\_candidat} qui trouve
le candidat qui peut être majoritaire: 
\begin{lstlisting}[language=C]
void trouve_candidat ( int * t , int * candidat ) ;  
\end{lstlisting}
avec \texttt{t} l'adresse de la première case d'un tableau de
\texttt{TAILLE} entiers, et \texttt{candidat} l'adresse de la variable
dans laquelle il faut mettre la valeur trouvée.

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
void trouve_candidat ( int * t , int * candidat )
{
    int i ;
    int majorite ;
    for ( i = 0 , majorite = 0 ; i < TAILLE ; i++ )
        if ( majorite == 0 )
        {
            majorite = 1 ;
            *candidat = t[i] ;
        }
        else
        {
            if ( t[i] == *candidat )
                majorite += 1 ;
            else
                majorite -= 1 ;
        }
}    
  \end{lstlisting}
\end{solutioncachee}

\question Écrire la fonction \texttt{verifie\_candidat} qui vérifie
que le candidat trouvé est majoritaire.
\begin{lstlisting}[language=C]
int verifie_candidat ( int * t , int candidat ) ;  
\end{lstlisting}

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int verifie_candidat ( int * t , int candidat )
{
    int i ;
    int occurrences ;
    for ( i = 0 , occurrences = 0 ; i < TAILLE ; i++ )
        occurrences += ( t[i] == candidat ) ;
    return ( occurrences > ( TAILLE / 2 ) ) ;
}    
  \end{lstlisting}
\end{solutioncachee}

\question Afin de vérifier le résultat, écrire une fonction qui
affiche le contenu du tableau d'entiers.

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int
affiche_tableau ( int * t )
{
    int i ;
    for ( i = 0 ; i < TAILLE ; i++ )
        printf ( "%d " , t[i] ) ;
    printf ( "\n" ) ;
    return 0 ;
}
  \end{lstlisting}
\end{solutioncachee}

\question Complétez la fonction \texttt{main} et vérifiez que votre programme marche. Il est conseillé de prendre de choisir \(n=2\) ou \(n=3\) pour avoir de bonnes chances d'avoir un élément majoritaire.

\begin{solutioncachee}
  \begin{lstlisting}[language=C]
int 
main ( int argc , char * argv[] )
{
    int n ;
    int t[TAILLE] ;
    int candidat ;
    srand ( time ( NULL ) ) ;
    printf ( "Choisissez le nombre de valeurs différentes possibles:\n" ) ;
    lit_entier_positif ( & n ) ;
    initialise ( t , n ) ;
    affiche_tableau( t ) ;
    trouve_candidat ( t , & candidat ) ;
    if ( verifie_candidat ( t , candidat ) )
    {
        printf ( "L'élément %d est majoritaire.\n" , candidat ) ;
    }
    else
    {
        printf ( "Il n'y a pas d'éléments majoritaires dans le tableau.\n") ;
    }
    return 0 ;
}
  \end{lstlisting}
\end{solutioncachee}

\exo{Tri lent}
% 4

\exo{Tri rapide}
% 5


% tri fusion et tri avec qsort dans le thème pointeurs