Développement C

L2 CUPGE 2018–2019

Travaux pratiques Fractions

1

Introduction

Le but de ce thème est de traduire des réels de l’intervalle [0, 1] en fractions à une précision
donnée près. On va travailler sur 5 fichiers :
— le src/Fractions/fraction.mk pour compiler automatiquement les fichiers ;
— le fichier src/Fractions/fraction.c qui contiendra l’implémentation des fractions ;
— le fichier include/fraction.h qui contiendra les en-têtes des fonctions et types définis ;
— le fichier src/Fractions/test_fraction.c qui contiendra les tests sur les fractions ;
— le fichier src/Fractions/recherche.c qui contiendra les sources du programme bin/fraction
de recherche de fraction.

2

Compilation

Pour eﬀectuer les tests, on va réutiliser les fichiers tests.h et la librairie entrees. Assurezvous qu’ils sont bien dans le répertoire ~/src/include. Cela signifie que parmi les options de
gcc, lors de la compilation, il faut ajouter :
-I "~programmation-en-C/src/include"
De plus, pour voir plus facilement le résultat des tests, il faut compiler avec :
-DUSECOLORS
Ensuite, quand on en sera à la version finale, on enlèvera les tests en compilant avec l’option :
-Dproduction
Enfin, pour utiliser la fonction fabsl : double → double qui calcule la valeur absolue d’un
double et est définie dans la bibliothèque <math.h>, il faut compiler avec l’option :
-lm
On paramétrise le fraction.mk avec des variables en le commençant par les lignes suivantes :
GCC=gcc
LIBS=-lm -lentrees
INCLUDE=-I "~/programmation-en-C/src/include"
FLAGS=-DUSECOLORS
On peut utiliser ces variables dans les règles. Par exemple :
test_fraction : test_fraction.c fraction.c
$(GCC) $(FLAGS) -o $@ $@.c $(INCLUDE) $(LIBS)
INCLUDE=-I "~/src/include"
FLAGS=-DUSECOLORS
1

Test du Makefile. On peut préciser ce qui va être fait en marquant le but d’une règle. Par
exemple :
\ t e x t t t {make −f f r a c t i o n . mk t e s t \ _ f r a c t i o n }

3

Fichier fraction.c

I Exercice : Base sur les structures

(a) Déclarer une structure fraction_s qui contient deux entiers, un numérateur p et un
dénominateur q.
Solution
struct f r a c t i o n _ s {
int p ;
int q ;
} ;

(b) Déclarer un nouveau type fraction qui est le type des structures fraction_s.
Solution
typedef struct f r a c t i o n _ s f r a c t i o n ;

(c) Écrire une fonction nouvelle_fraction qui prend en entrée deux entiers, et qui renvoie
une fraction avec ces entiers comme, respectivement, le numérateur et le dénominateur.
Solution
fraction
n o u v e l l e _ f r a c t i o n ( int p , int q )
{
fraction r
;
r .p = p ;
r .q = q ;
return r ;
}

(d) Écriture deux fonctions numerateur et denominateur qui renvoient respectivement le
numerateur et le dénominateur de la fraction passée en entrée.

2

Solution
int
numerateur ( fraction f )
{
return f.p ;
}
int
denominateur ( fraction f )
{
return f.q ;
}
Note de bonne programmation. Dans la suite, utilisez uniquement les fonctions nouvelle_fraction,
numerateur, et denominateur.

II Exercice : Opérations simples sur les fractions

(a) Écrire une fonction fractioncmp qui prend en entrée deux fraction f1 et f2 et rend un
entier du même signe que f1 − f2 (pour l’opération habituelle de soustraction).
Solution

int f r a c t i o n c m p ( f r a c t i o n a , f r a c t i o n b )
{
return numerateur ( a ) ∗ denominateur ( b ) − numerateur ( b ) ∗ denomina
}
\ q u e s t i o n {\ 'E} c r i r e ␣une␣ f o n c t i o n ␣\ c f u n { p r i n t \ _ f r a c t i o n }␣ q u i ␣ a f f i c h e ␣une
fraction .
\ begin { s o l u t i o n }
\ b e g i n { l s t l i s t i n g } [ l a n g u a g e=C]
␣ void
print_fraction␣(␣ fraction ␣ f ␣)
{
␣␣ p r i n t f ␣ ( ␣ " ␣␣%d\n−−−−−−−−\n␣␣%d\n " ␣ , ␣ numerateur ␣ ( ␣ f ␣ ) ␣ ,
␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣ denominateur ␣ ( ␣ f ␣ ) ␣ ) ␣ ;
}

(b) Écrire une fonction addition_cancre qui fait l’addition des cancres de 2 fractions :
p p′
p + p′
⊕ ′ =
q q
q + q′
On note qu’il s’agit aussi de l’addition des professeurs, puisque

3

5
8

⊕

8
12

=

13
.
20

Solution
fraction
addition_cancre ( fraction f1 , fraction f2 )
{
return nouvelle_fraction ( numerateur ( f1 ) + numerateur ( f2 ) ,
denominateur ( f1 ) + denominateur ( f2 ) ) ;
}
(c) Écrire une fonction eval_fraction qui renvoie le nombre (de type double) qui est la
valeur de la fraction passée en argument.
Solution
double
eval_fraction ( fraction f )
{
return ( ( double ) numerateur ( f ) ) / denominateur ( f ) ;
}

III Exercice : Recherche par dichotomie d’une fraction
L’addition des cancres permet de trouver par dichotomie la forme réduite d’une fraction
approchant un nombre positif. La justification mathématique est donnée par le lemme suivant [ ?] :
Lemme 1. Si

a
b

<

p
q

<

c
d

et si ad − bc = −1 alors :
{
p > a+b
q > b+d

Donc si on cherche un rationnel entre deux autres nombres qu’on aura calculé, soit il est
égal à leur somme des cancres, soit il est entre leur somme des cancres et l’un des deux, et ses
numérateurs et dénominateurs sont plus grand que ceux de la somme des cancres.
(a) En déduire une fonction ftofraction qui prend en entrée un double et rend une fraction
irréductible égale à ce double à une précision ε près.
Aide. Il faut commencer par se ramener au cas d’un nombre entre 0 et 1, puis faire une
recherche dichotomique en partant de 0 = 01 et +∞ = 01 .
Aide pour le C. Pour calculer la valeur absolue, utilisez la fonction fabsl définie dans
math.h.
Solution
fraction
f t o f r a c t i o n ( double x , double e p s i l o n )
{
double e ;

4

f r a c t i o n min = n o u v e l l e _ f r a c t i o n ( 0 , 1 ) , // z e r o
max = n o u v e l l e _ f r a c t i o n ( 1 , 0 ) ; // + i n f i n i
f r a c t i o n courant ;

do {
c o u r a n t = a d d i t i o n _ c a n c r e ( min , max ) ;
e = eval ( courant ) ;
if ( e < x )
min = c o u r a n t ;
else
max = c o u r a n t ;
} while ( f a b s l ( e − x ) > e p s i l o n ) ;
return c o u r a n t ;
}

4

Écriture d’un programme

On veut maintenant écrire un programme complet qui va eﬀectuer la mise sous forme de
fraction d’un décimal. Lors de l’appel —i.e., au début de la fonction main— le programme
commence par regarder combien il a d’arguments :
— s’il en a 0, il demande (en utilisant LireDecimal) à l’utilisateur un nombre à chercher
et une précision ;
— s’il en a 1, on suppose que c’est le nombre à chercher, et on utilise la précision par défaut
de 0.00000001 ;
— s’il en a 3, le premier doit être la chaîne de caractères "-p", le second la précision, et le
troisième est le nombre à chercher.

IV Exercice : Utilisation des arguments
Implémentez ce programme dans un fichier recherche.c.

5

Solution
#include
#include
#include
#include
#include

<s t d i o . h>
< s t d l i b . h>
<math . h>
" fraction . h"
" entrees . h"

void
d e m a n d e _ u t i l i s a t e u r ( double ∗ x , double ∗ e p s i l o n )
{
p r i n t f ( " Entrez ␣un␣nombre␣à␣ t r a d u i r e ␣ en ␣ f r a c t i o n :\n " ) ;
lire_decimal_long ( x ) ;
p r i n t f ( " Entrez ␣ l ' e r r e u r ␣ a d m i s s i b l e ␣ e p s i l o n :\n " ) ;
do {
lire_decimal_long ( epsilon ) ;

6

} while ( ∗ e p s i l o n < 0 ) ;
}

int
main ( int a r g c , char ∗ argv [ ] )
{
double x , e p s i l o n ;
switch ( a r g c )
{
case 1 :
d e m a n d e _ u t i l i s a t e u r ( &x , &e p s i l o n ) ;
break ;
case 2 :
x = a t o f ( argv [ 1 ] ) ;
e p s i l o n = 0.00000001 ;
break ;
case 4 :
i f ( strcmp ( argv [ 1 ] , "−p " ) == 0 )
{
x = a t o f ( argv [ 3 ] ) ;
e p s i l o n = a t o f ( argv [ 2 ] ) ;
}
else
goto erreur_argument ;
break ;
default :
goto erreur_argument ;
}
print_fraction ( ftofraction ( x , epsilon ) ) ;
return 0 ;
erreur_argument :
p r i n t f ( " U t i l i s a t i o n :␣%s ␣ [[ − p␣<p r e c i s i o n >]␣<x >]\n " , argv [ 0 ] ) ;
return 1 ;
}

5

Programmation modulaire

Le fichier fraction.h a un défaut, qui est minime pour nous, mais qui est handicapant pour
les gros programmes : les programmeurs qui l’utilisent peuvent créer de nouvelles structures en
dehors des fonctions qu’on a défini car ils ont accès au format de la structure.
La technique permettant d’éviter cela consiste à déclarer le type fraction non plus comme
une structure fraction, mais comme un pointeur vers une telle structure. Si les fichiers ont été
écrits correctement, ce changement est très rapide.

V Exercice : Changement de type des fractions

7

(a) Changez le type fraction en un type qui pointe sur des structures dans fraction.h
et fraction.c.
Solution
typedef struct f r a c t i o n _ s

∗ fraction ;

(b) Changez les fonctions nouvelle_fraction, numerateur, et denominateur du fichier
fraction.c pour les adapter au nouveau type.
(c) Recompilez test_fraction et recherche.
(d) Enlever la déclaration de la structure fraction_s du fichier fraction.h. Recompilez
test_fraction et recherche.
Solution
GCC=g c c
LIBS=−lm . . / l i b / c o u r s . o
INCLUDE=−I " . . / i n c l u d e / "
FLAGS=−DUSECOLORS

fraction . o : fraction . c
$ (GCC) $ (FLAGS) −c $< $ (INCLUDE)
test_fraction : test_fraction . c fraction . c
$ (GCC) $ (FLAGS) −o $@ $@. c $ (INCLUDE) $ ( LIBS )
fraction : recherche . c fraction . o
$ (GCC) $ (FLAGS) −o $@ r e c h e r c h e . c $ (INCLUDE) $ ( LIBS ) f r a c t i o n . o
recherche : recherche . c fraction . o
$ (GCC) $ (FLAGS) −o $@ r e c h e r c h e . c $ (INCLUDE) $ ( LIBS ) f r a c t i o n . o

8

