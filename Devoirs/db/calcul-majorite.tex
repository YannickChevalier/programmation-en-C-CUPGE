\exo{Calcul de majorit{\'e} (14 pts)}

\begin{quotation}
  \sl Lors de l'ouverture de fichiers, il est demandé de faire
  attention aux cas possibles d'erreur.
\end{quotation}

  Un \emph{automate cellulaire unidimensionnel born{\'e}} est
  d{\'e}fini par un tableau fini de \emph{cellules}. Chaque \emph{cellule}
  est d{\'e}finie par un {\'e}tat. Cet automate cellulaire \emph{{\'e}volue} suivant une
  \emph{fonction de transition} qui indique comment chaque cellule doit 
  {\'e}voluer en regardant son {\'e}tat et celui de ses voisines.

  Cet exercice porte sur le probl{\`e}me de recherche de majorit{\'e} avec un
  automate cellulaire unidimensionnel born{\'e}. Les {\'e}tats ne peuvent
  {\^e}tre que \texttt{oui} ou \texttt{non}, et on veut faire {\'e}voluer un
  automate pour que toutes ses cellules soient {\`a} \texttt{oui} s'il y a
  une majorit{\'e} de oui-s, ou \texttt{non} s'il y a une majorit{\'e} de non-s.

  Une solution (qui ne marche pas toujours, car le probl{\`e}me n'a pas de
  solutions en g{\'e}n{\'e}ral) consiste {\`a} utiliser la fonction de transition
  suivante:
  \begin{itemize}
  \item Si l'{\'e}tat de la cellule $i$ est \texttt{oui}, alors le nouvel 
  {\'e}tat est celui de la majorit{\'e} entre cette cellule, celle {\`a} 
  l'adresse $i-1$, et celle {\`a} l'indice $i-3$ ;
  \item Si l'{\'e}tat de la cellule $i$ est \texttt{non}, alors le nouvel 
  {\'e}tat est celui de la majorit{\'e} entre cette cellule, celle {\`a} 
  l'adresse $i+1$, et celle {\`a} l'indice $i+3$.
  \end{itemize}
  Les indices dans le tableau sont modulo $n$, le nombre de cellules 
  dans l'automate cellulaire unidimensionnel.

\vspace*{1em}

\question (1 pt) Pour simplifier le calcul de majorit{\'e}, on veut d{\'e}finir
une cellule comme pouvant avoir 2 {\'e}tats, \texttt{oui} et
\texttt{non}, avec \texttt{oui} qui vaut $1$, et \texttt{non} qui vaut
$-1$. D{\'e}finir le type \texttt{cellule} des cellules.


\question (1 pt) On d{\'e}finit maintenant les automates comme des couples ayant:
\begin{enumerate}
\item un tableau de cellules;
\item un entier $n$ indiquant le nombre de cellules dans l'automate.
\end{enumerate}.
D{\'e}finir la structure \texttt{automate\_s} de ces couples, ainsi que le type 
\texttt{automate} des pointeurs vers ces structures.


\question (2 pts) {\'E}crire une fonction \url{nouvel_automate} qui
prend en entr{\'e}e un entier $n$, et qui rend un automate pouvant
contenir $n$ cellules. \textit{Il n'est pas demand{\'e} d'initialiser la
  valeur de ces cellules.}


Pour simplifier le traitement des erreurs, dans la suite, vous pouvez
utiliser la fonction \emph{erreur}, qui s'utilise exactement comme la
fonction \emph{printf}, mais termine le programme imm{\'e}diatement quand
elle est appel{\'e}e. Par exemple:

\begin{Ccode}
  \ctab \cif ( ( \emph{f} $=$ \url{fopen}( \emph{fichier}, \texttt{"r"}) ) $==$ \texttt{NULL} )
  \ctab\hspace*{2em}  \url{erreur} ( \texttt{"Impossible d'ouvrir le fichier \%s en lecture, fin."} , \emph{fichier} ) ;
\end{Ccode}



\question (2 pts) {\'E}crire une fonction \url{lire_etat_initial} qui
prend en entr{\'e}e le \emph{nom} d'un fichier, et qui:
\begin{itemize}
\item ouvre ce fichier en lecture ;
\item lit un entier $n$, qui sera la taille de l'automate, dans ce fichier;
\item construit un automate ayant $n$ cellules ;
\item lit les $n$ valeurs de cellules stock{\'e}es dans le fichier 
(le caract{\`e}re \texttt{'.'} pour \texttt{non}, et le caract{\`e}re 
\texttt{'*'} pour \texttt{oui}, aucun autre caract{\`e}re n'est autoris{\'e}).
\item ferme le fichier.
\end{itemize}

\paragraph{Exemple.} On donne ci-dessous un fichier bien formatt{\'e} qui doit {\^e}tre lu sans erreurs:
\begin{verbatim}
30
...**.*.***..**..**...***..***
\end{verbatim}

\question (2 pts) {\'E}crire une fonction \url{ecrire_automate} qui
prend en entr{\'e}e un fichier ouvert en {\'e}criture (de type \texttt{FILE
*}) et un automate, et {\'e}crit les cellules de l'automate sur une ligne
de ce fichier.


\question (2 pts) {\'E}crire une fonction \url{vote} qui prend en entr{\'e}e
un automate $a$ et le num{\'e}ro $i$ d'une cellule de cet automate, et
renvoie le nouvel {\'e}tat pour la cellule $i$ de $a$. \textit{Rappel: 
l'op{\'e}rateur C \% calcule le ``modulo'': $7\% 5 == 2$  mais \(-3 \% 5 == -3\)}.




\question (1 pt) {\'E}crire une fonction \url{suivant} qui prend en
entr{\'e}e un automate et renvoie un nouvel automate contenant
l'évolution de toutes les cellules de l'automate en argument de la fonction.


\question (2 pts) {\'E}crire une fonction \url{evolution} qui prend en
entr{\'e}e le nom d'un fichier et:
\begin{enumerate}
\item lit l'automate $a$ qui est d{\'e}finit au d{\'e}but de ce fichier;
\item r{\'e}-ouvre ce fichier en \emph{{\'e}criture en ajout};
\item calcule les 100 {\'e}volutions de l'automate $a$, et {\'e}crit dans 
le fichier tous les automates calcul{\'e}s;
\item referme le fichier.
\end{enumerate}
Comme pr{\'e}c{\'e}demment, il est demand{\'e} de faire tr{\`e}s attention {\`a} tous les
cas possibles d'erreur.


\question (1 pt) {\'E}crire la fonction \url{main} d'un programme qui
prend en entr{\'e}e exactement 1 argument, qui est le nom d'un fichier. Le
programme doit compl{\'e}ter le fichier en {\'e}crivant les 100 automates qui
suivent celui qui est d{\'e}j{\`a} dans le fichier.

\paragraph{Exemple.} {\`A} la fin, le fichier a la forme suivante (les
derni{\`e}res lignes sont enlev{\'e}es car toutes identiques):

\begin{verbatim}
30
...**.*.***..**..**...***..***
....****.**..**..**..*.**.****
...*.***.**..**..**.**..******
..*.*.**.**..**..**.**.*******
.***...*.**..**..**.**********
****..*...*..**..*************
****..*......**.**************
****..*.......****************
****..*......*.***************
****..*.....*.*.**************
****..*....*.*.*.*************
****..*...*.*.*.*.************
****..*..*.*.*.*.*.***********
****..*.***.*.*.*.*.**********
****.***.*****.*.*.*.*********
*****************.*.*.********
********************.*.*******
***********************.******
******************************
******************************
\end{verbatim}

