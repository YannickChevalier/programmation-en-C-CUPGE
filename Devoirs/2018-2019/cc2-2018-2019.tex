\def\modulename{pcp}
\RequirePackage[utf8]{course}
\pcp
\newif\ifsolution
\solutiontrue
\usepackage{listings}

\lstset{language=C}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{units}
\usepackage{Cdefs}
\usepackage{tikz}
\usetikzlibrary{arrows}

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, white, font=\sffamily\bfseries, draw=black,
    fill=black, text width=1.5em},% arbre rouge noir, noeud noir
  arn_r/.style = {treenode, circle, red, draw=red, 
    text width=1.5em, very thick},% arbre rouge noir, noeud rouge
  arn_x/.style = {treenode, rectangle, draw=black,
    minimum width=0.5em, minimum height=0.5em}% arbre rouge noir, nil
}

\def\consigne#1{\null\begin{center}\parbox{13cm}{\large #1}\end{center}\relax}

\def\Question#1#2{\question{}\textbf{(#2)} #1}
\ifsolution
\includecomment{solution}
\else
\excludecomment{solution}
\fi

\begin{document}
\controlecontinu

\consigne{{\bf Dur{\'e}e: 1h30. Aucun document n'est autorisé.}}

\begin{solution}
  Note de l'auteur: les solutions proposées sont complètes (de mon
  point de vue) et sont écrites pour être compréhensibles avec les
  rappels de cours qui vont avec. Il n'est pas nécessaire d'écrire
  toutes les étapes pour avoir les points, ni même d'avoir le bon
  résultat: juste savoir ou expliquer comment il aurait fallu faire
  est récompensé.
\end{solution}

\vspace*{1em}

\exo{Codage (3 points)}

\begin{solution}
  Correction en cours
\end{solution}

\question Donnez, lorsque c'est possible, le codage en complément à 2
sur \(4\) et \(6\) bits des entiers \(-8,-7,-1,0,1,7,8\) (\(-0,25\)
par mauvaise réponse).


\exo{Test de compréhension (3 points)}

\begin{solution}
  Correction en cours
\end{solution}

On rappelle la règle: si la valeur \(x\) est l'adresse d'une case de type \(t\):
\begin{center}
  ( int ) ( x + 1 ) = ( ( int ) x ) + sizeof ( t ) 
\end{center}


On considère le programme suivant:
\begin{lstlisting}[language=C]
#include <stdio.h>
struct s {
  int a ;
  float b ;
} ;

int main ( int argc , char * argv[] )
{
  struct s t[3][2]  ;
  struct s * p1 = ( struct s * ) ( *t + 1 ) ;
  struct s * p2 = ( struct s * ) ( t + 1 ) - 1 ;
  printf ( "%d %d %d\n" , ( int ) t , ( int ) p1 , ( int ) p2 - 1 ) ;
  return 0 ;
}
\end{lstlisting}

Dire quelles sont les valeurs affichées. Il est demandé d'utiliser un
schéma détaillé de la mémoire pour justifier la réponse.

\exo{Calcul de majorit{\'e} (14 pts)}


  Un \emph{automate cellulaire unidimensionnel born{\'e}} est
  d{\'e}fini par un tableau fini de \emph{cellules}. Chaque \emph{cellule}
  est d{\'e}finie par un {\'e}tat. Cet automate cellulaire \emph{{\'e}volue} suivant une
  \emph{fonction de transition} qui indique comment chaque cellule doit 
  {\'e}voluer en regardant son {\'e}tat et celui de ses voisines.

  Cet exercice porte sur le probl{\`e}me de recherche de majorit{\'e} avec un
  automate cellulaire unidimensionnel born{\'e}. Les {\'e}tats ne peuvent
  {\^e}tre que \texttt{oui} ou \texttt{non}, et on veut faire {\'e}voluer un
  automate pour que toutes ses cellules soient {\`a} \texttt{oui} s'il y a
  une majorit{\'e} de oui-s, ou \texttt{non} s'il y a une majorit{\'e} de non-s.

  Une solution (qui ne marche pas toujours, car le probl{\`e}me n'a pas de
  solutions en g{\'e}n{\'e}ral) consiste {\`a} utiliser la fonction de transition
  suivante:
  \begin{itemize}
  \item Si l'{\'e}tat de la cellule $i$ est \texttt{oui}, alors le nouvel 
  {\'e}tat est celui de la majorit{\'e} entre cette cellule, celle {\`a} 
  l'adresse $i-1$, et celle {\`a} l'indice $i-3$ ;
  \item Si l'{\'e}tat de la cellule $i$ est \texttt{non}, alors le nouvel 
  {\'e}tat est celui de la majorit{\'e} entre cette cellule, celle {\`a} 
  l'adresse $i+1$, et celle {\`a} l'indice $i+3$.
  \end{itemize}
  Les indices dans le tableau sont modulo $n$, le nombre de cellules 
  dans l'automate cellulaire unidimensionnel.

\vspace*{1em}

\question (1,5 pts) Écrire une fonction prenant en entrée une chaîne de
caractères et renvoyant le nombre de caractères qu'elle contient, le
\texttt{'\textbackslash 0'} final compris).

\begin{solution}
  \begin{lstlisting}
int longueur ( char * s )
{
  int i ;
  for ( i = 0 ; s[i] != '0' ; i++ )
    ;
  return i + 1 ;
}    
  \end{lstlisting}
\end{solution}


\question (1,5 pts) Écrire une fonction indiquant (avec une réponse vrai
ou faux) si une chaîne de caractères ne contient que des \texttt{'.'}
et des \texttt{'*'}. Il est demandé que la fonction ne lise chaque caractère
de la chaîne qu'une seule fois et qu'elle n'utilise pas la fonction précédente.

\begin{solution}
  \begin{lstlisting}
int chaine_ok ( char * s )
{
  int i ;
  for ( i = 0 ; s[i] != '0' ; i++ )
    if ( ( s[i] != '.' ) || ( s[i] != '*' ) )
      return 0;
  return 1 ;
}    
  \end{lstlisting}
\end{solution}

\question (1 pt) Pour simplifier le calcul de majorit{\'e}, on veut
d{\'e}finir une cellule comme pouvant avoir 2 {\'e}tats, \texttt{oui}
et \texttt{non}, avec \texttt{oui} qui vaut $1$, et \texttt{non} qui
vaut $-1$. D{\'e}finir le type \texttt{cellule} des
cellules. \paragraph{Attention: il ne faut pas confondre les
  caractères '.' et '*' avec ces valeurs.}

\begin{solution}
  \begin{lstlisting}
typedef enum { oui = 1 , non = 0 } cellule ; 
  \end{lstlisting}
\end{solution}


\question (2 pts) On d{\'e}finit maintenant les automates comme des
couples ayant:
\begin{enumerate}
\item l'adresse d'un tableau de cellules;
\item un entier $n$ indiquant le nombre de cellules dans l'automate.
\end{enumerate}.
D{\'e}finir la structure \texttt{automate\_s} de ces couples, ainsi que le type 
\texttt{automate} de ces structures.

\begin{solution}
  \begin{lstlisting}
/*
  La question a ete simplifiee pour le CC: l'automate devrait
  etre une adresse de structure
*/
struct automate_s {
  cellule * t ;
  int nb_cellules ;
} ;
typedef struct automate_s automate ; 
  \end{lstlisting}
\end{solution}



{\bf On suppose qu'il existe une fonction \texttt{nouvel\_automate}
  qui prend en entrée un entier \(n\), et renvoie une valeur de type
  \texttt{automate} pouvant contenir une ligne de \(n\)
  cellules. Le code de cette fonction est donné à titre indicatif, mais ne sera pas utilisé.}

\begin{lstlisting}
automate nouvel_automate ( int n )
{
  automate res ;
  res.ligne = ( cellule * ) malloc ( n * sizeof ( int ) ) ;
  res.taille = n ;
  return res ;
}
\end{lstlisting}

\question (2 pts) {\'E}crire une fonction \url{lire_etat_initial} qui
prend en entr{\'e}e une chaîne de caractères, et qui:
\begin{itemize}
\item calcul sa longueur \(n\) ;
\item vérifie que la chaîne ne contient que des \texttt{'.'}
et des \texttt{'*'} (erreur sinon);
\item construit un automate ayant \(n\) cellules ;
\item lit les $n$ valeurs de cellules stock{\'e}es dans la chaîne de caractères
(le caract{\`e}re \texttt{'.'} pour \texttt{non}, et le caract{\`e}re 
\texttt{'*'} pour \texttt{oui}, aucun autre caract{\`e}re n'est autoris{\'e}).
\end{itemize}

\paragraph{Exemple.} On donne ci-dessous une chaîne de caractères bien
formatt{\'e}e qui doit {\^e}tre lue sans erreurs:
\begin{verbatim}
...**.*.***..**..**...***..***
\end{verbatim}
\begin{solution}
  \begin{lstlisting}
/*
   des erreurs sont possibles, donc on renvoie un int:
   int lire_etat_initial ( automate * res , char * s ) ;
*/
int lire_etat_initial ( automate * res , char * s )
{
  automate a ;
  int n ;
  int i ;
  n = longueur ( s ) ;
  if ( ! chaine_ok ( s ) )
    return 1 ;
  a = nouvel_automate ( n - 1 ) ; // le '\0' ne compte pas
  for ( i = 0 ; i < n - 1 ; i ++ )
    if ( s[i] == '*' )
      a.t[i] = oui ;
    else
      a.t[i] = non ;
  // fin: on stocke le resultat et on indique qu'il n'y a pas d'erreurs
  * res = a ;
  return 0 ;
} 
  \end{lstlisting}
\end{solution}

\question (1 pt) {\'E}crire une fonction \url{affiche_automate} qui
affiche la valeur des cellules de l'automate sur une ligne de ce fichier.

\begin{solution}
  \begin{lstlisting}
void affiche automate ( automate a )
{
  int i ;
  for ( i = 0 ; i < a.nb_cellules ; i++ )
    if ( a.t[i] == oui )
      printf ( "*" ) ;
    else
      printf ( "." ) ;
  printf ( "\n" ) ;
}
  \end{lstlisting}
\end{solution}

\question (2 pts) {\'E}crire une fonction \url{vote} qui prend en entr{\'e}e
un automate $a$ et le num{\'e}ro $i$ d'une cellule de cet automate, et
renvoie le nouvel {\'e}tat pour la cellule $i$ de $a$. \textit{Rappel: 
l'op{\'e}rateur C \% calcule le ``modulo'': $7\% 5 == 2$  mais \(-3 \% 5 == -3\)}.

\begin{solution}
  \begin{lstlisting}
cellule vote ( automate a , int i )
{
  int majorite ;
  int n = a.nb_cellules ;
  if ( a.t[i] == oui )
    majorite = a.t[i] + a.t[ ( i + n - 1 ) % n ] + a.t[ ( i + n - 3 ) % n ] ;
  else
    majorite = a.t[i] + a.t[ ( i + 1 ) % n ] + a.t[ ( i + 3 ) % n ] ;
  if ( majorite > 1 )
    return oui ;
  else
    return non ;
}
  \end{lstlisting}
\end{solution}

\question (1 pt) {\'E}crire une fonction \url{suivant} qui prend en
entr{\'e}e un automate et renvoie un nouvel automate contenant
l'évolution de toutes les cellules de l'automate en argument de la fonction.

\begin{solution}
  \begin{lstlisting}
automate suivant ( automate a )
{
  automate res ;
  int i ;
  res = nouvel_automate ( a.nb_cellules ) ;
  for ( i = 0 ; i < a.nb_cellules ; i++ )
    res.t[i] = vote ( a, i ) ;
  return res ;
}
  \end{lstlisting}
\end{solution}

\question (2 pts) {\'E}crire une fonction \url{evolution} qui prend en
entr{\'e}e une chaîne de caractères et:
\begin{enumerate}
\item lit l'automate $a$ qui est d{\'e}finit par cette chaîne;
\item calcule et affiche les 100 {\'e}volutions de l'automate $a$.
\end{enumerate}
Comme pr{\'e}c{\'e}demment, il est demand{\'e} de faire tr{\`e}s
attention {\`a} tous les cas possibles d'erreur.

\begin{solution}
  \begin{lstlisting}
int evolution ( char * s )
{
  automate automate_courant , automate_suivant ;
  int i ;
  if ( lire_etat_initial ( & automate_courant , s ) )
  {
    printf ( "erreur, chaine %s invalide\n" , s ) ;
    return 1 ;
  }
  for ( i = 0 ; i < 100 ; i++ )
  {
    affiche_automate ( automate_courant ) ;
    automate_suivant = suivant ( automate_courant ) ;
    automate_courant = automate_suivant ;
  }
  affiche_automate ( automate_courant ) ;
  return 0; 
}
  \end{lstlisting}
\end{solution}

\paragraph{Exemple.} Si le programme lit la première ligne, il affiche
(les derni{\`e}res lignes sont enlev{\'e}es car toutes identiques):

\begin{verbatim}
...**.*.***..**..**...***..***
....****.**..**..**..*.**.****
...*.***.**..**..**.**..******
..*.*.**.**..**..**.**.*******
.***...*.**..**..**.**********
****..*...*..**..*************
****..*......**.**************
****..*.......****************
****..*......*.***************
****..*.....*.*.**************
****..*....*.*.*.*************
****..*...*.*.*.*.************
****..*..*.*.*.*.*.***********
****..*.***.*.*.*.*.**********
****.***.*****.*.*.*.*********
*****************.*.*.********
********************.*.*******
***********************.******
******************************
******************************
\end{verbatim}



\end{document}

