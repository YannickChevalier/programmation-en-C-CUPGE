\RequirePackage{expl3}
\RequirePackage{tikz}
\usetikzlibrary{shapes.arrows,positioning,chains}
\ProvidesPackage{tikzSD}




% id of the SD
\newcounter{sdnum}
% position of current node in the SD
\newcounter{stepnum}[sdnum]
\newcounter{previousstepnum}[sdnum]

\global\def\arrowlength{.5*\sdunitfactor}


% parsing the type of nodes
\ExplSyntaxOn

\def\parseleftoutput#1#2{%\typeout{output left}%
\global\def\outputstate{t}\global\def\outleft{t}\global\def\sdnodetype{#2}}
\def\parserightoutput#1#2{%\typeout{output right}
\global\def\outputstate{t}\global\def\outleft{f}\global\def\sdnodetype{#2}}
\def\parsenooutput#1{\global\def\outputstate{f}\global\def\sdnodetype{#1}}

\def\parsetype {
  \set_node_property{type}\nextchar
}

\def\parseoutput{%
\ifx\nextchar w
   \set_node_property{output}{left}\futurelet\nextchar\parsetype
\else
   \ifx\nextchar e
       \set_node_property{output}{right}\futurelet\nextchar\parsetype
   \else
       \parsetype\nextchar
   \fi
\fi}
\def\typeOf{\futurelet\nextchar\parseoutput}




\int_new:N \sd_count
\int_gset:Nn \sd_count {0}




\cs_new:Npn \parse_node_in_sd #1, {
  
  \int_gincr:N \current_sd_node_number
}

\cs_new:Npn \parse_symbolic_derivation_aux #1,#2; {
  \ifx x#2x
     \parse_node_in_sd #1,
  \else
     \parse_node_in_sd #1,
     \parse_symbolic_derivation_aux #2;
  \fi
}

\cs_new:Npn \parse_symbolic_derivation #1 {
  \int_gincr:N \sd_count
  \int_gset:Nn \current_sd_node_number {0}
  \parse_symbolic_derivation_aux #1,;
}

\ExplSyntaxOn

\cs_generate_variant:Nn \prop_gput:Nnn {Nxx}
\cs_generate_variant:Nn \prop_gget:NnN {NxN}


%%% Data structures for nodes
% All infos are stored in property lists

\prop_new:N \g_node_variable_prop
\tl_new:N \p_node_variable_content


\cs_new:Npn \set_node_variable #1#2 {
  % usage: \verb+\set_node_variable{node-id}{variable content}
  % One must protect commands from expansion using \verb+\noexpand+
  % whenever necessary. E.g.: \noexpand\ensuremath{\noexpand\mathcal{X}_\var_number}
  \prop_gput:Nxx \g_node_variable_prop #1 {#2}
}

\cs_new:Npn \get_node_variable #1 {
  % usage: \verb+\get_node_variable{node-id}{variable content}
  \prop_gget:NxN \g_node_variable_prop #1 \p_node_variable_content
}

% nodes

\prop_new:N \g_node_type_prop
\prop_new:N \g_node_couleur_prop
\prop_new:N \g_node_variable_prop
\prop_new:N \g_node_equation_prop
\prop_new:N \g_node_equation_prop



\cs_new:Npn \get_node_property #1#2 {
  % usage: \verb+\get_node_variable{node-id}{typename}
  \tl_clear:N \l_output_variable
  \expandafter\prop_gget:NxN \csname g_node_#2_prop\endcsname #1 \l_output_variable
  \l_output_variable
}



\cs_new:Npn \parse_argument #1=#2, {
  \expandafter\prop_gput:Nxx
     \csname g_node_#1_prop\endcsname
     \current_node_id {#2}
}

\cs_new:Npn \parse_node #1,#2; {
  \ifx&#2&%
     % #2 is empty, we process the last argument
       \parse_argument #1,
   \else
       \parse_argument #1,
       \parse_node #2;
   \fi
}

\cs_new:Npn \set_node_property #1#2 {
  \xdef\current_node_id{#1}
  \parse_node #2,;
}



\ExplSyntaxOff


% putting the nodes at the right place
\global\def\sdunitfactor{1}
\global\def\abscisse{3*\thesdnum*\sdunitfactor}
\global\def\ordonnee{\thestepnum*\sdunitfactor}

% naming nodes
\global\def\nodename#1#2{sd#1-#2}
\global\def\currentnodename{\nodename{\varname}{\thestepnum}}


% en general,\def\nodevariable{\ensuremath{#2_{#3}}}
% en general,\def\nodeequation{\ensuremath{\nodevariable\unif\currentterm}}
\global\def\sdnode{%
\draw (\abscisse,\ordonnee)
      node[circle,draw, 
           label=above right:{\nodevariable},
           label={[label distance=-3mm]below right:{\nodeequation}},
           name=\currentnodename]
           {\step};
\if t\inputstate 
\draw[red,<-]  (\currentnodename) --  \if t\inleft +(-\arrowlength,0)\else +(\arrowlength,0)\fi;
\fi
\if t\outputstate 
\draw[green,->] (\currentnodename) -- \if t\outleft +(-\arrowlength,0)\else +(\arrowlength,0)\fi ;
\fi
\if t\lastvisible \draw[->] (\nodename{\varname}{\thepreviousstepnum}) -- (\currentnodename);\fi
}



% wr -> reuse state, output west
% ed -> deduction state, output east


\global\def\symbolicderivation#1#2{
  \stepcounter{sdnum}
  \def\varname{#1}
  \draw (\abscisse,\ordonnee) node (sd\varname-\thestepnum) {SD \varname} ;
  \global\def\lastvisible{f}
  \foreach \step/\completetype/\param in {#2} {
%    \tracingall
    \stepcounter{stepnum}
    % default values
    \global\def\inputstate{f}
    \global\def\outputstate{f}
    \global\def\nodevariable{\ensuremath{\varname_{\step}}}
    \global\def\nodeequation{}
    % parsing whether this is an output node
    \expandafter\typeOf\completetype
    \if t\outputstate \fi %\typeout{output+}\fi
    \if h\sdnodetype
       %\typeout{hidden, }
       \global\def\lastvisible{f}
    \else
       \if r\sdnodetype
          %\typeout{reuse, }
          \global\def\nodevariable{\ensuremath{{\varname}_{\param}}}
        \else\fi
        \if d\sdnodetype
           %\typeout{deduction, }
           \global\def\nodeequation{\ensuremath{\nodevariable\unif\param}}
        \else\fi
        \if i\sdnodetype
           %\typeout{input, }
           \global\def\inputstate{t}
           \if l\param
           \global\def\inleft{t}\else\global\def\inleft{f}\fi
        \fi
        \def\tracingall{0}
        \sdnode
        \global\def\lastvisible{t}
     \fi % end "visible step"
    \stepcounter{previousstepnum}
  } % fin de la boucle for
}

\def\connecttoright#1#2{\draw[color=blue,style=->] (#1) .. controls +(right:1cm) and +(left:1cm) .. (#2);}
\def\connecttoleft#1#2{\draw[color=blue,style=->] (#1) .. controls +(left:1cm) and +(right:1cm) .. (#2);}

\def\orderto#1#2{\draw[style=->] (#1) -- (#2);}

\ExplSyntaxOff
