\documentclass[a4paper]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{beton}
\usepackage{amsmath}
\usepackage{url}
\usepackage{gnuplot-lua-tikz}

\newif\ifmmesi
\mmesifalse





\def\titre{L2 CUPGE}
\def\datefin{14 d{\'e}cembre 2018}
\renewcommand{\max}{\text{\rm max}}
\title{Projet en langage C:\\
Mod{\'e}lisation de la trajectoire d'un point}
\author{\titre}
\date{Ann{\'e}e 2018--2019}

\newcommand{\vit}[1]{\ensuremath{\frac{d #1}{dt}}}
\begin{document}

\maketitle

\section{Introduction}

Le but de ce projet est de permettre de repr{\'e}senter graphiquement la
trajectoire d'un point {\'e}tant donn{\'e}es les {\'e}quations aux d{\'e}riv{\'e}es
partielles d{\'e}finissant cette trajectoire. Lorsque le point est soumis
{\`a} des forces d{\'e}pendant uniquement de sa position et de sa vitesse, le
Principe Fondamental de la dynamique implique qu'il est possible de
calculer sa trajectoire en fonction de ces deux param{\`e}tres. Dans ce
projet, on part des {\'e}quations d{\'e}finissant la vitesse en fonction de la
vitesse et de la position, et on met {\`a} jour la position du point en
fonction de la vitesse et d'un petit incr{\'e}ment de temps param{\'e}trable
$dt$. Par exemple, pour les {\'e}quations de Lorenz:
$$
\left\lbrace
  \begin{array}{rcl}
    \vit x &=& \sigma ( y - x )\\
    \vit y &=& x ( \rho - z ) - y \\
    \vit z &=& xy - \beta z\\
  \end{array}
\right.
$$
et avec $dt=0.01$, un point dont la position est $\vec u=(x,y,z)$ et
la vitesse est $\vec v=(\vit x,\vit y,\vit y)$ {\`a} l'instant $t$ aura, {\`a}
l'instant $t+dt$, la position $(x+\vit x\cdot dt,y+\vit y \cdot dt,
z+\vit z \cdot dt)$ et la vitesse $(\sigma ( y - x ), x ( \rho - z ) -
y, xy - \beta z)$. Les param{\`e}tres $\sigma$, $\rho$, et $\beta$ sont
fix{\'e}s pour chaque trajectoire calcul{\'e}e.

Le programme demandera {\`a} l'utilisateur des param{\`e}tres pour le calcul
de la trajectoire, l'incr{\'e}ment $dt$, la position initiale $(x,y,z)$
(on suppose que le point est initialement stationnaire), et le temps
d'arr{\^e}t $T_{\max}$. Il calculera ensuite toutes les coordonn{\'e}es des
points entre $t=0$ et $t=T_\max$ (attention, il y en a
$\frac{T_\max}{dt}$) et les stockera dans un fichier dans le format:
\begin{center}
  temps  x y z
\end{center}
La trajectoire sera trac{\'e}e avec \texttt{gnuplot}, en utilisant les
commandes:
{\tt\begin{itemize}
\item[$\rangle$] set parametric
\item[$\rangle$] splot "lorenz.dat" u 2:3:4
\end{itemize}}\noindent
si le fichier de sortie s'appelle \texttt{lorenz.dat}.

\section{Objectifs}

L'objectif de base du projet est de parvenir {\`a} afficher la courbe
correspondant aux coordonn{\'e}es initiales $(1,2,3)$ pour les {\'e}quations
de Lorenz avec les param{\`e}tres $\sigma=10, \rho=28, \beta=\frac
83$. Au-del{\`a} de cet objectif de base, plusieurs extensions sont
possibles, donc (liste non-exclusive):
\begin{itemize}
\item (facile) Demander les param{\`e}tres et la position initiale {\`a}
  l'utilisation ;
\item (facile) Cr{\'e}er plusieurs fonctions pour donner {\`a} l'utilisateur
  le choix entre diff{\'e}rents syst{\`e}mes dynamiques ;
\item (mod{\'e}r{\'e}) {\'E}crire des modules lisant les param{\`e}tres et effectuant
  la mise {\`a} jour d'un point pour diff{\'e}rents syst{\`e}mes. Il faut pour
  cela utiliser une structure sera commune {\`a} ces modules et dont les
  membres sont les fonctions d'initialisation, de mise {\`a} jour des
  coordonn{\'e}es, ainsi que les param{\`e}tres eux-m{\^e}mes.
\item (mod{\'e}r{\'e}--difficile) Demander {\`a} l'utilisateur de d{\'e}finir les
  param{\`e}tres et la mise {\`a} jour de la vitesse, et tracer ensuite la
  courbe.
\item (difficile) Utiliser une biblioth{\`e}que d'interfa{\c c}age entre C et
  Gnuplot pour lancer les commandes et tracer la graphique {\`a} partir du
  programme.
\item (difficile) Lire la documentation de Gnuplot pour r{\'e}ussir {\`a}
  afficher (au choix):
  \begin{itemize}
  \item la vitesse par des vecteurs;
  \item la vitesse par une couleur;
  \item le temps par un changement de couleur.
  \end{itemize}
\item (au-del{\`a} du cours) Lancer le programme gnuplot {\`a}
  partir du programme cr{\'e}{\'e} pour qu'il affiche la courbe sans avoir
  besoin de repasser par la ligne de commande.
\end{itemize}
Le premier point est ``requis'' pour avoir la moyenne, mais pas pour
pouvoir rendre le projet. Le second est un bonus facile {\`a} obtenir une
fois que les fonctions pour le cas des {\'e}quations de Lorenz ont {\'e}t{\'e}
{\'e}crites. Le troisi{\`e}me point est plus difficile, mais ne va pas au-del{\`a}
de ce qui a {\'e}t{\'e} vu en cours/TP. La difficult{\'e} principale est dans la
d{\'e}finition de la structure qui sera commune {\`a} tous les modules.

On rentre dans le C avanc{\'e} {\`a} partir du quatri{\`e}me point. Une
possibilit{\'e} est de demander {\`a} l'utilisateur de rentrer les formules en
notation polonaise invers{\'e}e, avec des param{\`e}tres sur une lettre, et
ensuite, pour la mise {\`a} jour de la vitesse, de parcourir la cha{\^\i}ne de
caract{\`e}re entr{\'e}e pour l'utilisateur pour construire une liste des
valeurs. Par exemple, avec la cha{\^\i}ne:
\begin{center}
  "s x y - *"
\end{center}
on part de la liste vite, on ajoute $s$, puis $x$, puis $y$ (pour
obtenir la liste des valeurs de $[y;x;s]$. Lorsqu'on arrive au
caract{\`e}re $-$, on lit les deux premiers {\'e}l{\'e}ments et on ajoute leur
diff{\'e}rence pour obtenir la liste $[y-x;s]$. Lorsqu'on arrive au
caract{\`e}re $-$, on lit les deux premiers {\'e}l{\'e}ments et on ajoute leur
diff{\'e}rence pour obtenir la liste $[(y-x)*s]$. Arriv{\'e} {\`a} la fin de la
cha{\^\i}ne de caract{\`e}res, on rend la valeur de son premier {\'e}l{\'e}ment.

Une biblioth{\`e}que d'interfa{\c c}age entre C et \texttt{Gnuplot} a
{\'e}t{\'e} {\'e}crite par Nicolas Devillard et est
t{\'e}l{\'e}chargeable sur Internet. La difficult{\'e} ici consiste
surtout {\`a} comprendre, {\`a} partir de la documentation, comment
elle fonctionne pour pouvoir l'utiliser.  De m{\^e}me, la
difficult{\'e} du 6{\`e}me point est la difficult{\'e} de la lecture
de la documentation de \texttt{Gnuplot}.  Pour ces 2 probl{\`e}mes, il
est important de r{\'e}aliser que la lecture et la compr{\'e}hension
d'une documentation sont des parties tr{\`e}s importantes de la
programmation (et plus g{\'e}n{\'e}ralement des m{\'e}tiers
d'ing{\'e}nierie).

Le dernier point est difficilement classable. Il est relativement
simple une fois que la mani{\`e}re dont les programmes sont
cr{\'e}{\'e}s sous Unix est bien connue, mais nous ne les aurons pas
vus dans ce cours.  Ce point consiste donc en une auto-formation {\`a}
la programmation syst{\`e}me.

\paragraph{Important.} Les points list{\'e}s comme difficiles peuvent
prendre beaucoup de temps. Il est vivement recommand{\'e} de ne les
aborder qu'une fois les points pr{\'e}c{\'e}dents {\'e}crits, et s'il
reste un temps raisonnable avant de rendre le projet.

\section{Modalit{\'e}s}

Le projet doit être fait par binômes. Chaque binôme doit:
\begin{itemize}
\item mettre en place un dépôt privé auquel seuls les membres du groupe
  et l'enseignant de TP peut accéder;
\item faire des \emph{commit} réguliers pour qu'il soit possible
  d'évaluer qui a contribué à quels aspects du projet.
\end{itemize}

Le projet est en 2 phases: à la fin de la première phase le groupe
doit avoir un plan pour pouvoir guider l'écriture du code, et le code
source du programme doit être rendu à la fin de la seconde phase.

\subsection{Première phase: Description du projet}

\begin{center}
  \bf Date de retour:  16 novembre 2018
\end{center}

On demande au groupe de fournir un plan détaillé pour l'architecture
du code source du programme. Même si ça n'a pas encore été vu au
moment de la conception, vous serez capable, au moment de l'écriture:
\begin{itemize}
\item de lire et écrire des données dans des fichiers;
\item de définir des types de données regroupant plusieurs valeurs
  (comme un triplet de \texttt{float}, etc.);
\item d'écrire des tests permettant de savoir si les fonctions que
  vous écrirez sont correctes;
\item d'écrire une documentation.
\end{itemize}

\paragraph{Guide pour l'architecture du répertoire.}
Idéalement, le nom de votre dépôt sera de type \texttt{Dupont-Dupond}
(les noms des membres). Il contiendra au moins des sous-répertoires
\texttt{src}, \texttt{lib}, \texttt{include}, \texttt{bin}, et
\texttt{doc}, et un fichier \texttt{Makefile}\footnote{L'écriture de
  ce type de fichiers sera vue en TP} permettant de compiler, tester,
et exécuter votre programme. 

\paragraph{Rapport de fin de première phase.}
Le rapport doit contenir un plan très détaillé de ce que vous allez
faire. \textbf{Une liste n'est pas suffisante}. Vous devez organiser
votre projet autour de plusieurs librairies (que vous définirez), et
ce plan doit comporter une section par librairie. Chaque section doit
contenir un court paragraphe de description g{\'e}n{\'e}rale sur le
thème commun aux fonctions et types de cette librairie. Ensuite, pour
chaque type et fonction d{\'e}clar{\'e}e, d'une description avec:
\begin{itemize}
\item la déclaration de la fonction ;
\item Une description de ce que fera la fonction, 
\item Si la fonction a besoin d'autres fonctions que vous aurez à
  écrire pour ses calculs, une description des données que vous
  passerez à ces fonctions, et la liste des fonctions que vous utiliserez.
  \begin{center}
    Il faut veiller à ce que les données passées aux fonctions aient
    un type compatible avec la déclaration de cette fonction !
  \end{center}
\end{itemize}

Une section suppl{\'e}mentaire sera utilis{\'e}e pour d{\'e}crire les d{\'e}pendances
entre librairies, et l'organisation du programme principal.

Ce rapport sera noté en fonction de la profondeur de votre réflexion sur les
difficultés que vous pourrez avoir et les solutions que vous proposez. 

\subsection{Seconde phase: le programme}

\begin{center}
   \bf Date de retour:  7 décembre 2018
\end{center}

Le projet final \textbf{doit} contenir:
\begin{itemize}
\item un fichier Makefile permettant de compiler le programme ;
\item un sous-r{\'e}pertoire \texttt{doc} contenant:
  \begin{itemize}
  \item la description initiale du projet (le rapport de la phase 1)
  \item un fichier indiquant comment utiliser le programme (entre un
    paragraphe et une page, sauf si le programme est extrèmement compliqué);
  \item un second rapport indiquant les changements par rapport
    {\`a} l'architecture que vous aviez décrite dans le premier rapport;
  \end{itemize}
\item les fichiers sources, organis{\'e}s comme il vous plaira.
\end{itemize}

Il est normal, et encore plus pour un premier projet de programmation,
d'avoir des différences entre ce qu'on pensait faire et ce qu'on a
vraiment fait. Le second rapport sert à justifier les changements que
vous avez fait ! 

\subsection{Bar\^eme}

Le bar\^eme suivant est indicatif\ldots
\begin{description}
\item[Documentation:] ~
  \begin{description}
  \item[Dépôt:] Mise en place correcte et partage 3, utilisation
    fréquente de git 2;
\item[Pr\'e-rapport:] Pr\'esentation du rapport 2, compl\'etude (de la description
des fonctions, des modules, etc.) 2, clart\'e des explication sur les choix (de
d\'ecoupage, d'options choisies, de structures de donn\'ees choisies, etc.) 2,
richesse de la réflexion 2;
\item[Rapport final:] explication des corrections par rapport aux
  sources du programme final 5, manuel d'utilisation 2, présentation/clart\'e 2;
\end{description}
\item[Programme:] documentation du code 2, Makefile 3, compilation 2,
  tests 2
  qualité de la décomposition en librairies 5, contenu 2$\times$
  nombre d'options au-delà de la deuxième, clarté du code 2;
\end{description}
La facilit\'e d'extension est fonction de la modularit\'e et du
d\'ecoupage du code en petites unit\'es (libraries, fichiers .c,
fonctions) qu'il est facile de changer si on veut ajouter des options
suppl\'ementaires. Un extr\`eme, o\`u tout le code est dans la
fonction \texttt{main}, correspond \`a une note de 0. La clarté du
code est jugée sur la non répétition de morceaux de code similaires qui
pourraient \^etre remplac\'e par un morceau de code commun (avec des
param\`etres suppl\'ementaires, en g\'en\'eral).

Le bar\^eme est normalis\'e \`a 20 en divisant par $2$ (ce qui correspond \`a 2 options).


\vfill

\input lorenz-res

\vfill
\end{document}
